\input texinfo
@setfilename fiona.info
@include version.texi
@afourpaper
@finalout
@settitle Fiona User's Manual

@c --------------------------------------------------------------------------

@copying
@ifnothtml

@b{About this document:}

This manual is for Fiona, version @value{VERSION}, a tool to analyze interacting open nets, last
update @value{UPDATED}.

Copyright @copyright{} 2008 Peter Massuthe, Daniela Weinberg

@quotation Permission is granted to copy, distribute and/or modify this document under the terms of
the GNU Free Documentation License, Version 1.3 or any later version published by the Free Software
Foundation; with no Invariant Sections, with the Front-Cover Texts being ``A GNU Manual,'' and with
the Back-Cover Texts as in (a) below.  A copy of the license is included in the section entitled
``GNU Free Documentation License.''

(a) The FSF's Back-Cover Text is: ``You are free to copy and modify this GNU Manual. Buying copies
from GNU Press supports the FSF in developing GNU and promoting software freedom.'' @end quotation

@end ifnothtml
@end copying

@dircategory service-technology.org
@direntry
* fiona: (fiona).       Fiona.
@end direntry


@c --------------------------------------------------------------------------

@titlepage

@title Fiona

@subtitle A Tool to Analyze Interacting Open Nets
@subtitle @url{http://service-technology.org/fiona}
@vskip 0.5em
@subtitle Version @value{VERSION}, @value{UPDATED}

@author Peter Massuthe
@author Daniela Weinberg
@page


@vskip 0pt plus 1filll
@insertcopying
@end titlepage

@c --------------------------------------------------------------------------

@ifnottex
@node Top
@top Fiona
@insertcopying
@end ifnottex

@c --------------------------------------------------------------------------

@menu
* Introduction::Introduction
* Context::Context
* Running Example::Running Example
* Input and Output File Formats::Input and Output File Formats
* How to Use Fiona::How to Use Fiona
* Some last Words::Some last Words
* References::References
* First Steps::How to set up and install Fiona.
* ChangeLog::Version history.
* GNU Free Documentation License::The license of this manual.
@end menu

@c --------------------------------------------------------------------------

@contents
@paragraphindent none

@c --------------------------------------------------------------------------

@node Introduction
@chapter Introduction

This documentation presents Fiona, a tool to analyze the interaction of services. Its features
cover the check of controllability and the construction of an operating guideline of a service as
well as other derived notions. @i{Controllability} [1,2] is a minimal correctness criterion of a
service stating the existence of a behaviorally compatible partner for the service. An @i{operating
guideline} (OG) [3] of a service is an operational characterization of @i{all} behaviorally
compatible partners of this service. As a formal model for services Fiona uses @i{open nets} [4,3],
a special class of Petri nets that extend classical Petri nets by an interface for communication
with other open nets.

The development of Fiona started in 2006 as a reimplementation of a tool called Wombat (available
at @url{http://www.informatik.hu-berlin.de/top/wombat}). Wombat was designed to constructively
decide controllability of an open net (called workflow module in Wombat). The main reasons for a
reimplementation were (1) a completely new theoretical foundation for deciding controllability, (2)
a desired focus on efficiency rather than mere effectiveness, (3) the newly developed concept of an
operating guideline, and, thus, (4) the need for a separation of computing compatible interactions
from reduction rules to ensure efficiency of the algorithms.

Currently, Fiona is developed distributedly by the groups of Wolfgang Reisig
(Humboldt-Universit@"at zu Berlin, Germany) and Karsten Wolf (University of Rostock, Germany). It
is maintained by Daniela Weinberg, Peter Massuthe, and Karsten Wolf (coordinator).

Fiona is released as free software under the terms of the GNU General Public License. It is written
in C++ and its distribution is based on the GNU autotools, which provide the possibility to run
Fiona on most operating systems. It compiles on Microsoft Windows (with Cygwin), UNIX (Solaris),
Linux, and Mac OS X.

The functionality of Fiona comprises (among others) the following main analysis scenarios:

@itemize
@item @b{Controllability.} Controllability of an open net @math{N} is decided by
synthesizing a partner of @math{N} (as an automaton called @i{interaction graph} (IG) [2]). If no
partner can be synthesized (i.e., the IG is empty), then @math{N} is uncontrollable.

@item @b{Operating guideline.} An operating guideline (OG) [3] is a finite characterization of
@i{all} behaviorally compatible partners by annotating a single partner (as automaton) with Boolean
formulae in order to derive all other partners.

@item @b{Matching.} Given an open net @math{M} and an operating guideline @math{OG_N} of an open
net @math{N}, Fiona decides whether @math{M} is behaviorally compatible to @math{N} by matching
@math{M} with @math{OG_N}. Matching is more efficient than composing the two nets and model
checking the composition (as proposed by other approaches, like the @i{public view} approach).

@item @b{Partner synthesis.} Given an open net @math{N}, Fiona computes a behaviorally compatible
partner open net @math{M} (if possible). The synthesis can be triggered to construct a small
@math{M} (with respect to communication) or a partner @math{M} which exhaustively communicates with
@math{N}. @end itemize

Fiona is a stand-alone tool, designed to be used as a background service of existing service
modeling tools. Therefore, Fiona has no graphical interface --- the analysis task as well as the
input file(s) are given to Fiona via command line options. Fiona then computes and reports the
result and, if needed, generates the output file(s).


@c --------------------------------------------------------------------------

@node Context
@chapter Context

Fiona can be used within the new computing paradigms of service-oriented computing (@acronym{SOC})
and service-oriented architectures (@acronym{SOA}), as well as other areas of intra- and
interorganizational business process modeling and analysis. Therein, a @i{service} represents a
self-contained software unit that offers an encapsulated functionality via a well-defined
interface. Services are used as building blocks to implement complex, highly dynamic, and flexible
business processes. @acronym{SOA}s introduce a @i{service broker} to organize the challenges of
@i{service discovery}, i.e. the publishing and management of available services and the
introduction of procedures to enable a client to find and use such a service.

Controllability is a minimal requirement for the correctness of a service and is particularly
relevant for service designers. Operating guidelines are suited to support service discovery and
can be used to decide @i{substitutability of services} [5] or to generate @i{adapters} for
incompatible services [6]. Thus, Fiona is intended to be used by service designers, by service
providers, and by service brokers.



@c --------------------------------------------------------------------------

@node Running Example
@chapter Running Example

In the following sections we will describe the analysis scenarios of Fiona with the help of a small
example. Fig. 1 shows the open net model of an online shop. For a more detailed introduction into
open nets, please refer to [4,3].

Initially, the shop waits for a customer to log in (transition @sansserif{?login}). Then, the shop
decides internally whether the customer is new to the shop or if the customer has used the shop
before. That decision is reported to the customer (transitions @sansserif{!new} or
@sansserif{!known}). So, the customer receives either message. If the shop did not recognize the
customer, the shop expects the customer to accept the terms of payment of the shop (modeled by
sending a message @sansserif{terms} --- transition @sansserif{?terms}) and to send the order
(modeled by sending a message @sansserif{order} --- transition @sansserif{?order}). Afterwards, the
shop sends the delivery notice to the customer (transition @sansserif{!deliver}). If, however, the
customer is known to the shop, it will first expect the customer to send out his order (transition
@sansserif{?order}) and then, it will send a delivery message to the customer (transition
@sansserif{!deliver}). The online shop reaches its final state after the delivery notice has been
sent out (place @sansserif{p9} is marked).

@sp 1
@center @image{figs/online_shop.owfn}
@sp 1
@center @b{Figure 1.} Online Shop as an Open Net
@sp 2

You can find the example online shop in file @file{docShop.owfn} in the documentation directory of
your Fiona distribution.



@c --------------------------------------------------------------------------

@node Input and Output File Formats
@chapter Input and Output File Formats

@menu
* Open Nets::
* Operating Guidelines::
* Adapter Rules::
* Covering Open Net Nodes::
@end menu


Fiona supports different types of input files --- open net files and operating guideline files.
Here, it ignores every file extension and checks the type of an input file by its content. So, an
open net file or an operating guideline file may contain any file extension, for example
@samp{.net} or @samp{.whatever} is possible.

@node Open Nets
@section Open Nets

@menu
* Places::
* Initial Marking::
* Final Markings::
* Transitions::
* Open Net Specification of the Online Shop::
@end menu

The open net file format (@samp{.owfn}) has been adapted from the LoLA [7] file format. It is
fairly easy to read and to comprehend. So, it is possible to model an open net manually.
Additionally, there exists a compiler BPEL2oWFN (available at
@url{http://service-technology.org/bpel2owfn}) that implements a feature-complete open net
semantics [8] for WS-BPEL and automatically generates an open net file for a given WS-BPEL process.

The Fiona distribution contains two directories, @file{nets} and @file{tests}, where you can find
many example open nets. The open net files have the extension @samp{owfn} (open workflow net). The
name of the open nets which are the output of Fiona and BPEL2oWFN will always end with
@samp{.owfn}.

In the remainder of this documentation we will always refer to such an open net file by calling it
@dfn{owfn-file}.

The two main differences between an open net and a Petri net are (1) the set of places is split up
into @i{internal}, @i{input}, and @i{output} places, and (2) there exists a set of final markings.

Therefore, the open net file consists of four parts:

@enumerate
@item Places
@item Initial Marking
@item Final Markings, and
@item Transitions
@end enumerate

We will describe each part in the following sections by successively specifying the online shop of
@ref{Running Example}.

You may comment the contents of the file. A comment is enclosed with curly brackets, i.e. @samp{@{
comment @}}. However, you may not use @samp{@{$ @dots{}  $@}}. This notion is used for debug
purposes.

@node Places
@subsection Places

Each open net file starts with the definition of its places. As mentioned above, the set of places
is divided into three (pairwise disjoint) parts: internal places (keyword @samp{PLACE}), input
places (@samp{INPUT}), and output places (@samp{OUTPUT}).

The online shop consists of 15 places: places @sansserif{p1}, @dots{}, @sansserif{p9} are internal
places, places @sansserif{login}, @sansserif{terms}, and @sansserif{order} are input places, and
places @sansserif{new}, @sansserif{known}, and @sansserif{deliver} are output places. We specify
this as follows.

@cartouche
@smallexample
 PLACE
   p1, p2, p3, p4, p5, p6, p7, p8, p9;
 INPUT
   login, terms, order;
 OUTPUT
   new, known, delivery;
@end smallexample
@end cartouche

The elements of a set of places are separated by comma. Each list ends with a semicolon. The place
names are arbitrary and do not conform to any scheme. An empty set of input places (output places
analogously) can either be specified by

@cartouche
@smallexample
 INPUT
   ;
@end smallexample
@end cartouche

or by simply omitting the keyword @samp{INPUT} and the following @samp{;} completely.


@node Initial Marking
@subsection Initial Marking

The @samp{PLACES} section is followed by the @samp{INITIALMARKING} section. Every place which is
not listed in the @samp{INITIALMARKING} section is implicitly assumed to have zero tokens
initially. If you want to create an initial state in which some places are marked, you have to list
exactly those places in the @samp{INITIALMARKING} section. Make sure that you specify the correct
number of tokens of each place.

Initially, the online shop waits for a customer to log in. So, the initial marking of the shop is
one token on place @sansserif{p1}.

@cartouche
@smallexample
 INITIALMARKING
   p1: 1;
@end smallexample
@end cartouche

You may omit the explicit @i{one token}. If you do not specify how many tokens there shall be, then
Fiona implicitly assumes the marking to be one token only. So, the following specification has the
same meaning as the one stated above.

@cartouche
@smallexample
 INITIALMARKING
   p1;
@end smallexample
@end cartouche

Suppose, we would have specified the initial marking to be two tokens on place @sansserif{p1}. Then
you would specify this by

@cartouche
@smallexample
 INITIALMARKING
   p1: 2;
@end smallexample
@end cartouche

or

@cartouche
@smallexample
 INITIALMARKING
   p1, p1;
@end smallexample
@end cartouche

which has the same meaning.

@node Final Markings
@subsection Final Markings

@menu
* Final markings::
* Final conditions::
@end menu

The third section lets you specify one or more final markings. There are two possibilities to
define final markings which are described in the following: either @samp{FINALMARKING} or
@samp{FINALCONDITION}.

@node Final markings
@subsubsection Final markings

The final marking is specified in the same manner as the initial marking (@pxref{Initial Marking}).
The final marking of the online shop is one token on place @sansserif{p9}. All other places of the
shop have to contain no token. You can specify this as follows.

@cartouche
@smallexample
 FINALMARKING
   p9 : 1;
@end smallexample
@end cartouche

You may also specify a set of final markings. Suppose, you want the shop to have three final
markings: (1) a token on @sansserif{p9}, (2) a token on @sansserif{p6} and @sansserif{p7}, and (3)
a token on @sansserif{p8}. You can specify this by

@cartouche
@smallexample
 FINALMARKING
   p9;  p6, p7;  p8;
@end smallexample
@end cartouche

If your net should not contain any final marking, you have to omit the section @samp{FINALMARKING}
continuing with the transitions section (@pxref{Transitions}).

In contrast, specifying

@cartouche
@smallexample
 FINALMARKING
   ;
@end smallexample
@end cartouche

characterizes exactly one final marking which is the unique marking where every place of your net
contains no token.

@node Final conditions
@subsubsection Final conditions

You can also use a powerful, implicit characterization of final markings by specifying a
@samp{FINALCONDITION} instead of @samp{FINALMARKING}.

@cartouche
@smallexample
 FINALCONDITION
   @i{condition};
@end smallexample
@end cartouche

Then, every marking that @i{satisfies} the @samp{@i{condition}} is accepted as a final marking. A
condition has the following structure:

@cartouche
@smallexample
  Condition := Place COMP Token | Condition OP Condition |
               Condition OP OTHERS-EMPTY | '(' Condition ')'
  COMP := '=' | '>' | '<' | '<=' | '>='
  OP := 'AND' | 'OR'
  OTHERS_EMPTY := 'ALL_OTHER_PLACES_EMPTY' |
                  'ALL_OTHER_INTERNAL_PLACES_EMPTY' |
                  'ALL_OTHER_EXTERNAL_PLACES_EMPTY'
@end smallexample
@end cartouche

So, a condition is either

@itemize
@item a declaration of how many tokens a place has to hold (@samp{p1 = 2}), or
@item a logical connection of two conditions using @samp{AND} or @samp{OR}, or
@item a logical connection of a condition and a @samp{OTHERS_EMPTY} predicate using @samp{AND} or @samp{OR}, or
@item bracketing a condition.
@end itemize

For instance, the condition

@cartouche
@smallexample
 FINALCONDITION
   p9 = 1;
@end smallexample
@end cartouche

accepts each marking with exactly one token on place @samp{p9} and arbitrarily many tokens on the
other places as a final marking. The condition

@cartouche
@smallexample
 FINALCONDITION
   p9 = 1 AND p1 = 0 AND p2 = 0 AND p3 = 0 AND
   p4 = 0 AND p5 = 0 AND p6 = 0 AND p7 = 0 AND
   p8 = 0 AND login = 0 AND terms = 0 AND
   order = 0 AND new = 0 AND known = 0 AND
   delivery = 0;
@end smallexample
@end cartouche

for the example online shop exactly corresponds to

@cartouche
@smallexample
 FINALMARKING
   p9 : 1;
@end smallexample
@end cartouche

The special predicates in @samp{OTHERS_EMPTY} can be used to avoid the lengthy definitions of
@samp{AND p1 = 0 AND p2 = 0 AND @dots{}} (as done in the example final condition above) by
requiring emptiness of a set of places. Such predicates can only be used in combination with a
``normal'' condition and the specified set depends on the places named in the condition.

For instance, the final condition

@cartouche
@smallexample
 FINALCONDITION
   (p9 = 1 AND ALL_OTHER_PLACES_EMPTY) OR
   (p8 = 1 AND ALL_OTHER_PLACES_EMPTY)
@end smallexample
@end cartouche

accepts final markings in which either (a) @samp{p9} contains 1 token and all other places of
the shop contain zero tokens, or (b) @samp{p8} contains 1 token and all other places contain
zero tokens. That is, the first @samp{ALL_OTHER_PLACES_EMPTY} predicate specifies emptiness
of the places @samp{p1}, @dots{}, @samp{p8}, whereas the second one specifies emptiness of
@samp{p1}, @dots{}, @samp{p7}, and @samp{p9}.


@node Transitions
@subsection Transitions

The last part of an open net file is an enumeration of the transitions of the net.

Suppose you would like to define transition @samp{?login}, which consumes one token from
place @samp{p1} and one token from input place @samp{login} and produces a token on place @samp{p2}.
Then you would specify it as follows.

@cartouche
@smallexample
 TRANSITION t1       @{?login@}
   CONSUME p1, login;
   PRODUCE p2;
@end smallexample
@end cartouche

By careful by naming each transition of the net. The names have to be unique. That is why we
chose to name that transition @samp{t1} with @samp{?login} as a comment only. The net might
contain another @samp{?login} transition.

The definition of the set of places from which the transition consumes tokens and to which it
produces tokens is again specified as stated in @ref{Initial Marking}.

@node Open Net Specification of the Online Shop
@subsection Open Net Specification of the Online Shop

The first part of the open net specification of the online shop looks like this.

@cartouche
@smallexample
 @{ "online shop" of fiona documentation @}

 PLACE INTERNAL
   p1, p2, p3, p4, p5, p6, p7, p8, p9;
 INPUT
   login, order, terms;
 OUTPUT
   new, known, deliver;

 INITIALMARKING
   p1;

 FINALMARKING
   p9;

 TRANSITION t1  @{ ?login @}
 CONSUME
   p1, login;
 PRODUCE
   p2;

 TRANSITION t2  @{ !new @}
 CONSUME
   p2;
 PRODUCE
   p3, p4, new;

 ...
@end smallexample
@end cartouche

@node Operating Guidelines
@section Operating Guidelines

@menu
* Operating Guidelines with Global Constraint::
@end menu

Fiona is able to read a textual representation of an operating guideline stored in a special
file format (og-file with extension @samp{.og}). Within an og-file the OG is stored as an
annotated graph: every node is annotated with a formula and a color. There exists a distinguished
initial node and all nodes are connected by labeled edges (@samp{TRANSITIONS}).

@cartouche
@smallexample
 NODES
     0 : (!login + !order) : blue,
    17 : !login : blue,
    18 : (?new * (?deliver + ?known)) : blue,
    19 : !terms : blue,
          ...
    21 : final : blue : finalnode,
          ...
 INITIALNODE
     0;

 TRANSITIONS
     0 -> 17 : !order,
     0 -> 38 : !login,
    17 -> 18 : !login,
    18 -> 19 : ?new,
    18 -> 28 : ?deliver,
          ...
@end smallexample
@end cartouche

Figure 2 shows the operating guideline of the online shop. The following
specification describes the first part of the og-file of the shop. You can find the text file
(@file{docShop.owfn.og}) in the documentation directory of your Fiona distribution. Or, you can
easily generate it by having Fiona calculate the operating guideline of the shop.

@sp 2
@center @image{figs/online_shop.owfn.og}
@center @b{Figure 2.} Operating Guideline of Online Shop
@sp 2

As you take a closer look at the textual specification you can see that node @samp{21} has an additional
attribute --- @samp{finalnode}. So, besides annotating a node with its boolean annotation and its
color, you can also declare a node to be a final node of the operating guideline. In the graphics
such a node will always be depicted with two surrounding lines.


@node Operating Guidelines with Global Constraint
@subsection Operating Guidelines with Global Constraint


Fiona can also read a textual specification of an extended operating guideline, i.e. an operating
guideline with a global constraint. An operating guideline with global constraint characterizes
behaviorally compatible partners @math{M} of an open net @math{N} such that a certain set @math{X} of
places and transitions of @math{N} is covered in the composition of @math{M} and @math{N}. Here, to
cover a place @math{p} means that @math{p} can be marked in some reachable marking of the
composition while to cover a transition @math{t} means that @math{t} is not dead. An operating
guideline with global constraint consists of an (ordinary) operating guideline and a constraint
specifying which nodes of the operating guideline have to be contained in the matching relation.
Files of such a kind of an operating guideline have the suffix @file{.covog}.

As an example, suppose we want to cover places @samp{p2} and @samp{p3} as well as transition
@samp{!new} (transition @samp{t2} of the open net specification) in our running example, the online
shop (@pxref{Running Example}). The resulting file (@file{docShop.owfn.covog}) looks like this.

@cartouche
@smallexample
  NODES
     0 : (!login + !order) : blue,
    17 : !login : blue,
    18 : (?new * (?deliver + ?known)) : blue,
    19 : !terms : blue,
          ...
    21 : final : blue,
          ...
    38 : ((!order + ?known) * (!order + ?new)) : blue,
          ...

  INITIALNODE
    0;

  TRANSITIONS
    0 -> 17 : !order,
    0 -> 38 : !login,
    17 -> 18 : !login,
    18 -> 19 : ?new,
    18 -> 28 : ?deliver,
    18 -> 36 : ?known,
          ...

  COVER
    Places to cover: p2 p3,
    Transitions to cover: t2,
    Global Constraint: (18 + 38),

     0 : none,
    17 : none,
    18 : p2 p3 t2,
    19 : p3,
         ...
    38 : p2 p3 t2,
    39 : none,
    41 : p3,
    42 : p3;

@end smallexample
@end cartouche

Up to the keyword @samp{COVER} the file contains the same information as the file of the ordinary
operating guideline (see @file{docShop.owfn.og}). After the keyword @samp{COVER} the set of places
to be covered and the set of transitions to be covered are listed. In the third line the global
constraint is shown (@samp{(18 + 38)}), meaning a behaviorally compatible partner @math{M} of the
shop covers nodes @samp{p2}, @samp{p3}, and @samp{!new} if it contains a state that matches with
node @samp{18} or with node @samp{38} of the shop's OG. Beneath the global constraint each node of
the operating guideline is listed and for each node the set of places and transitions of the online
shop covered by this node are specified. For example, node @samp{18} covers places @samp{p2},
@samp{p3}, and transition @samp{t2} of the online shop. Transition @samp{t2} is the internal name
of transition @samp{!new} (@pxref{Open Net Specification of the Online Shop}).


@node Adapter Rules
@section Adapter Rules

One of the analysis scenarios of Fiona is to generate an adapter which functions as a mediator
between different nets (@pxref{Further Analysis Scenarios}). In order to build such an adapter it
is necessary for the algorithm to know which messages can be mapped onto each other. We encode this
mapping in a special @i{adapter rules file} [6], commonly extended with @file{.ar}.

Consider the online shop as described in @ref{Running Example} again. Suppose that there exists
another net which models a potential customer of the shop. The composition of the two nets,
however, does not behave well. As you take a closer look at the services, you notice what the
problem is --- the customer net is only able to receive a message that is called
@samp{delivery_notice} as opposed to the message that the online shop sends out. That message is
called @samp{delivery}. You would now specify this fact as an adapter rule as follows.

@cartouche
@smallexample
  delivery_notice -> delivery;
@end smallexample
@end cartouche

Given the two nets and the adapter rule file Fiona will now be able to construct an adapter for the
two nets.

Specifying

@cartouche
@smallexample
  -> A ;
@end smallexample
@end cartouche

states that the adapter may generate message @samp{A}. And

@cartouche
@smallexample
  B -> ;
@end smallexample
@end cartouche

specifies that message @samp{B} may be deleted by the adapter. The following rules duplicate
message @samp{C} and split message @samp{D} into three parts --- @samp{E}, @samp{F}, and @samp{G}

@cartouche
@smallexample
  C -> C, C;
  D -> E, F, G;
@end smallexample
@end cartouche


@node Covering Open Net Nodes
@section Covering Open Net Nodes

Fiona can compute those behaviorally compatible partners @math{M} for an open net @math{N} such
that a certain set @math{X} of places and transitions of @math{N} is covered in the composition of @math{M}
and @math{N}. Covering a place @math{p} means that @math{p} is marked in some reachable marking
while to cover a transition @math{t} means that @math{t} is not dead. To this end one has to
specify the set @math{X} with the help of a cov-file.

A cov-file defines the set of places and transitions to be covered. It contains two keywords:
@samp{PLACES} and @samp{TRANSITIONS}. As in the case of an owfn-file after each keyword we specify
a list of places and transitions, respectively. Elements of these lists are divided by @samp{,} and
a list is completed by @samp{;}.

As an example, suppose we want to cover places @samp{p2} and @samp{p3} as well as transition
@samp{!new} in our running example, the online shop, as described in @ref{Running Example}. Then we
have the following file (@file{docShop.owfn.cov}). Please note, that in the open net specification
as of @ref{Open Net Specification of the Online Shop} the name of transition @samp{!new} is
@samp{t2}. So, we write @samp{t2} instead of @samp{!new} in the cov-file.

@cartouche
@smallexample
  PLACES
    p2, p3;
  TRANSITIONS
    t2;
@end smallexample
@end cartouche



@c --------------------------------------------------------------------------

@node How to Use Fiona
@chapter How to Use Fiona

@menu
* Main Analysis Scenarios::
* Further Analysis Scenarios::
* Preprocessing and Conversions::
* More Options::
@end menu

Fiona can be used in a broad range of service analysis scenarios. Each scenario
is invoked by a certain option and Fiona's output and behavior can then be modified
by various other options. Type

@cartouche
@smallexample
fiona --help
@end smallexample
@end cartouche

to get all available options you can use to control Fiona. By typing

@cartouche
@smallexample
fiona --version
@end smallexample
@end cartouche

Fiona will print out the complete version information.

In the following @ref{Main Analysis Scenarios} we describe the main analysis scenarios for which
Fiona can be used. In @ref{Further Analysis Scenarios} we briefly describe other analysis
scenarios, in @ref{Preprocessing and Conversions} and @ref{More Options} we show the options that
can be used to trigger the analysis tasks and/or to modify the output of Fiona.

@node Main Analysis Scenarios
@section Main Analysis Scenarios

Suppose the online shop of @ref{Running Example} is stored in file @file{docShop.owfn} in directory
@file{doc}.

@itemize
@item @b{Controllability.} You would now like to check if the online shop is controllable
or not. So, you type

@cartouche
@smallexample
fiona -t ig doc/docShop.owfn
@end smallexample
@end cartouche

to have Fiona check controllability. Fiona decides controllability by constructing an IG. After
computing the IG, Fiona reports whether the net is controllable or not. Furthermore, you will find
a graphic file showing the IG in directory @file{doc}. The graphics is generated by GraphViz Dot
(available at @url{http://www.graphviz.org}).

Depending on the size of the given open net, it may take some time for Fiona to build up the IG.
So, it is advisable to have Fiona build up a reduced interaction graph [2]. In general, the
resulting graph is significantly smaller than the complete IG and thus it takes less time to
compute it and it consumes less memory as it is constructed. Type

@cartouche
@smallexample
fiona -t ig -r doc/docShop.owfn
@end smallexample
@end cartouche

to calculate the reduced IG. There are different reduction techniques that can be applied to the
IG. Fiona provides the possibility to apply two of those reduction techniques independently. The
parameter @option{-p cre} refers to the reduction technique @dfn{combine receiving events} and the
parameter @option{-p rbs} refers to @dfn{receiving before sending}.

@cartouche
@smallexample
fiona -t ig -r -p cre doc/docShop.owfn
fiona -t ig -r -p rbs doc/docShop.owfn
@end smallexample
@end cartouche

@item @b{Operating guideline.} You would like to construct the operating guideline of the online
shop. You can do this by typing

@cartouche
@smallexample
fiona -t og doc/docShop.owfn
@end smallexample
@end cartouche

Fiona reports whether @math{N} is controllable or not and again you will find a graphic file
showing the OG in directory @file{doc}. Since Fiona just constructed an OG, it stores the
information of the OG textually in a file called @file{docShop.owfn.og}. You can also find this
file in directory @file{doc}.

You can also invoke Fiona to generate an OG as BDDs. Type

@cartouche
@smallexample
fiona -t og -b 0 doc/docShop.owfn
@end smallexample
@end cartouche

if the generated BDDs shall be reordered by @samp{CUDD_REORDER_SAME}.

@item @b{Matching.} Consider the following scenario. You would like to check whether your shop is
behaviorally compatible to another shop @file{otherShop.owfn} from which you have given its
corresponding og-file @file{otherShop.owfn.og} only. Use the following command for invoking the
matching algorithm.

@cartouche
@smallexample
fiona -t match doc/docShop.owfn ogs/otherShop.owfn.og
@end smallexample
@end cartouche

Fiona will report whether the net matches with the given OG or not. In case the matching fails,
Fiona reports where the failure manifests in.

@item @b{Partner synthesis.} Once you have modeled your service as an open net, you may be
interested in the possible partner services that can properly interact with your service. You can
use Fiona to automatically construct two different types of partners: a (very) small one or a
partner that exhaustively communicates with the net.

@cartouche
@smallexample
fiona -t smallpartner doc/docShop.owfn
fiona -t mostpermissivepartner doc/docShop.owfn
@end smallexample
@end cartouche

The partner open net is then modeled as an open net and you will find the corresponding file
@file{docShop-partner.owfn} in directory @file{doc}. Fiona generates the open net with the help of
the tool Petrify (available at @url{http://www.lsi.upc.es/~jordicf/petrify/distrib/home.html}).
@end itemize

@node Further Analysis Scenarios
@section Further Analysis Scenarios

In this section we describe further analysis scenarios.

@itemize
@item @b{Public View.} Suppose you would like to publish your online shop. You do not want
to publish any private information about which decision is taken and when. Then you would publish a
public view of your shop which hides any details of implementation. Invoke Fiona as follows to
generate such a public view.

@cartouche
@smallexample
fiona -t pv doc/docShop.owfn
@end smallexample
@end cartouche

Afterwards, you will find a file @file{docShop.pv.owfn} that specifies the public view of the shop
in directory @file{doc}. Further, Fiona generates a graphics that shows the open net of the public
view.

@item @b{Substitutability.} We distinguish different notions of substitutability [5]:
@dfn{accordance} and @dfn{equivalence}. Suppose you have modeled a new online shop and stored it in
file @file{myNets/myShop.owfn}. Now you would like to check whether the online shop of
@ref{Running Example} can be substituted by your online shop. Here, you have two options. You use
Fiona to check whether the set of compatible partners of your online shop is a subset of the set of
partners of the documentation online shop. To check this property, type

@cartouche
@smallexample
fiona -t simulation myNets/myShop.owfn doc/docShop.owfn
@end smallexample
@end cartouche

Typically, Fiona expects og-files as its input. If owfn-files are given, Fiona will first generate
an operating guideline of both nets and will then run the algorithm. Please be careful by invoking
Fiona as the order of the arguments is important. Fiona will print out whether your shop has at
least the partners of the documentation shop or not.

The second option is to check whether your online shop characterizes the same set of partners as
the documentation online shop. Invoke Fiona as follows to check equivalence.

@cartouche
@smallexample
fiona -t equivalence myNets/myShop.owfn doc/docShop.owfn
@end smallexample
@end cartouche

Here, the order of the given nets does not matter. But again, Fiona expects og-files as its input.
If owfn-files are given, Fiona will first generate an operating guideline of both nets to run the
algorithm. Finally, Fiona will state whether both nets specify the same partners or not.

@item @b{Adapter generation.} Suppose, in addition to the online shop you have given the model of a
customer as an owfn-file. You know that both nets are @i{not} behaviorally compatible. Further, you
have specified an adapter rule file @file{rules.ar} (@pxref{Adapter Rules}) which
defines certain message mappings. Then, you can use Fiona to synthesize a partner that functions as
an adapter for both nets. If such a partner exists, it mediates between both nets. Thus, the
composition of all three nets is well-behaving by construction. For more details see
[6]. Invoke Fiona as follows.

@cartouche
@smallexample
fiona -t adapter doc/docShop.owfn myNets/customer.owfn -a rules.ar
@end smallexample
@end cartouche

By invoking Fiona with

@cartouche
@smallexample
fiona -t smalladapter doc/docShop.owfn myNets/customer.owfn -a rules.ar
@end smallexample
@end cartouche

a rather small adapter will be generated by using certain reduction rules. In either case a file
called @file{docShop_customer_result.owfn} will be generated which models the adapter of the two
nets with respect to the adapter rules given.


@item @b{Covering open net nodes.} Suppose, we are interested in characterizing all behaviorally
compatible partners @math{M} of our online shop (@pxref{Running Example}) such that a certain set
@math{X} of places and transitions of the shop's underlying open net (@math{N}) is covered in the
composition of @math{M} and @math{N}. Here, to cover a place @math{p} means that @math{p} can be
marked in some reachable marking while to cover a transition @math{t} means that @math{t} is not
dead. To characterize those partners, we need an extended notion of an operating guideline -- an
operating guideline with global constraint, which consists of the operating guideline @math{OG_N}
and a global constraint @math{\psi} over the nodes of @math{OG_N}. Thereby @math{\psi} specifies
which nodes of @math{OG_N} must be contained in the matching relation of a partner and the
operating guideline. For more details see [9]. To compute an operating guideline with global
constraint, you need to specify the set of nodes (transitions and/or places) of @math{N} to be
covered (here: @file{docShop.owfn.cov}, @pxref{Covering Open Net Nodes}). Invoke Fiona as follows.

@cartouche
@smallexample
fiona -t og -p cover doc/docShop.owfn doc/docShop.owfn.cov
@end smallexample
@end cartouche

Fiona generates an output file @file{docShop.owfn.covog}, which contains the textual specification
of the operating guideline with global constraint. By invoking Fiona with

@cartouche
@smallexample
fiona -t og -p cover -s coverall doc/docShop.owfn
@end smallexample
@end cartouche

Fiona prints out which places and transitions of @math{N} are covered in each node of the operating
guideline. In order to check whether a given open net @math{M} is a behaviorally compatible partner
of @math{N} that covers the specified set of places and transitions invoke Fiona as follows.

@cartouche
@smallexample
fiona -t match -p cover doc/docShop.owfn myNets/covernet.owfn
@end smallexample
@end cartouche

@end itemize

@node Preprocessing and Conversions
@section Preprocessing and Conversions

We will now describe the options that either preprocess or convert a given input file.

Invoke Fiona by typing

@cartouche
@smallexample
fiona -t <parameter> FILES
@end smallexample
@end cartouche

Again, depending on the @samp{parameter} the variable @samp{FILES} stands for an open net, an
operating guideline or a set of open nets or operating guidelines. The @samp{parameter} may be any
of the following.

@multitable @columnfractions .022 .22 .60 .25 .022
@headitem @tab @option{<parameter>} @tab description @tab @code{FILES}
@item @tab @code{minimizeOG }@tab minimizes a given OG @tab og-file
@item @tab @code{reduce }@tab structurally reduce a given open net (choose reduction level using parameter @code{r1} ... @code{r5})@tab owfn-file
@item @tab @code{normalize }@tab normalize all given open nets @tab owfn-file
@item @tab @code{isacyclic }@tab check a given OG for cycles @tab og-file
@item @tab @code{count }@tab count the number of services that are characterized by a given OG @tab og-file
@item @tab @code{checkfalsenodes }@tab look for nodes that violate their own annotation in a given OG @tab og-file
@item @tab @code{removefalsenodes }@tab remove all nodes that violate their own annotation in a given OG @tab og-file
@item @tab @code{png }@tab generate png file of given open net @tab owfn-file
@end multitable
@sp 1

@node More Options
@section More Options

Fiona provides different options to modify the output, to speed up the computation or to control
the analysis tasks, for instance. In the following we will briefly describe every option.

@itemize

@item @b{Set message maximum.} Set the maximum number of same messages per state to @samp{<level>}
(in [3] this value is called @dfn{message bound}).

Option: @samp{--messagemaximum = <level>} or @samp{-m <level>}

If no message maximum is set manually, the default value @samp{1} is assumed.

@item @b{Reduce IG.} Generate a reduced IG by applying reduction techniques while the graph is
calculated. By default, the techniques @dfn{combine receiving events} and @dfn{receiving before
sending} are applied. This can be changed by specifying the desired techniques as parameters to
option @option{-p}. If any technique is given, only the specified reduction techniques are used.

Option: @option{--reduceIG} or @option{-r}

@item @b{Reduce Node states.} This reduction technique stores less states in each node of the IG/OG
and during the calculation of the graphs. So, in general it reduces memory. However, it might
increase the computation time.

Option: @option{--reduce-nodes} or @option{-R}

@item @b{Show additional information.} There are different display options for the graphics of
operating guidelines and interaction graphs.

Option: @option{--show = <parameter>} or @option{-s <parameter>}

Parameters:
@multitable @columnfractions .022 .17 .70 .022
@headitem @tab @option{<parameter>} @tab description
@item @tab @code{allnodes }@tab show all nodes of the graph
@item @tab @code{blue }@tab show blue nodes only (default)
@item @tab @code{rednodes }@tab show blue and red nodes (no empty node and no black nodes)
@item @tab @code{empty }@tab show empty node
@item @tab @code{allstates }@tab show all calculated states per node
@item @tab @code{deadlocks }@tab show all but transient states
@item @tab @code{coverall }@tab shows all covered open net nodes per OG node (only if @file{-p cover} is used)
@end multitable
@sp 1

@item @b{BDD Construction.} An operating guideline can be represented with BDDs. Here, the BDD is
created after the operating guideline has been calculated. The argument @samp{<reordering>}
specifies the type of reodering that is used.

Option: @option{--BDD=<reordering>} or @option{-b <reordering>}
@multitable @columnfractions .022 .17 .70 .022
@headitem @tab @code{<reordering>} @tab Command
@item @tab 0  @tab @code{CUDD_REORDER_SAME}
@item @tab 1  @tab @code{CUDD_REORDER_NONE}
@item @tab 2  @tab @code{CUDD_REORDER_RANDOM}
@item @tab 3  @tab @code{CUDD_REORDER_RANDOM_PIVOT}
@item @tab 4  @tab @code{CUDD_REORDER_SIFT}
@item @tab 5  @tab @code{CUDD_REORDER_SIFT_CONVERGE}
@item @tab 6  @tab @code{CUDD_REORDER_SYMM_SIFT}
@item @tab 7  @tab @code{CUDD_REORDER_SYMM_SIFT_CONV}
@item @tab 8  @tab @code{CUDD_REORDER_WINDOW2}
@item @tab 9  @tab @code{CUDD_REORDER_WINDOW3}
@item @tab 10 @tab @code{CUDD_REORDER_WINDOW4}
@item @tab 11 @tab @code{CUDD_REORDER_WINDOW2_CONV}
@item @tab 12 @tab @code{CUDD_REORDER_WINDOW3_CONV}
@item @tab 13 @tab @code{CUDD_REORDER_WINDOW4_CONV}
@item @tab 14 @tab @code{CUDD_REORDER_GROUP_SIFT}
@item @tab 15 @tab @code{CUDD_REORDER_GROUP_SIFT_CONV}
@item @tab 16 @tab @code{CUDD_REORDER_ANNEALING}
@item @tab 17 @tab @code{CUDD_REORDER_GENETIC}
@item @tab 18 @tab @code{CUDD_REORDER_LINEAR}
@item @tab 19 @tab @code{CUDD_REORDER_LINEAR_CONVERGE}
@item @tab 20 @tab @code{CUDD_REORDER_LAZY_SIFT}
@item @tab 21 @tab @code{CUDD_REORDER_EXACT}
@end multitable
@sp 1

@item @b{On the Fly BDD Construction.} An operating guideline can also be calculated as BDDs on the fly.

Option: @option{--OnTheFly=<reordering>} or @option{-B <reordering>}

Parameters: See @b{BDD Construction} for possible parameters.

@item @b{Output prefix.} Sets a prefix string to all output files.

Option: @option{--output=<filename prefix>} or @option{-o <filename prefix>}

@item @b{No output.} No output will be generated at all.

Option: @option{--no-output} or @option{-Q}

@item @b{Additional parameters.} Further modification of the execution.

Option: @option{--parameter=<parameter> } or @option{-p <parameter>}

Parameters:
@multitable @columnfractions .022 .17 .70 .022
@headitem @tab @code{<parameter>} @tab description
@item @tab @code{no-png} @tab does not create a PNG file
@item @tab @code{no-dot} @tab does not create dot related output
@item @tab @code{r1}--@code{r5} @tab set reduction level in mode @option{-t reduce}
@item @tab @code{cre} @tab use the ``combine receiving events''---reduction technique to reduce the IG
@item @tab @code{rbs} @tab use the ``receiving before sending''---reduction technique to reduce the IG
@item @tab @code{cover} @tab requires @file{-t og} or @file{-t match} and is used for OGs with global constraint
@end multitable
@sp 1

@item @b{Debug level.} The default compilation of Fiona provides the possibility to get complete
debug information.

Option: @option{--debug=<level>} or @option{-d <level>}

Here the parameter @samp{level} may be any of the following values, depending on the degree of
detailed information you wish Fiona to output.

@multitable @columnfractions .022 .10 .77 .022
@headitem @tab @code{<level>} @tab description
@item @tab @code{1} @tab show nodes and dfs information
@item @tab @code{2} @tab show analysis information (i.e. colors)
@item @tab @code{3} @tab show information on events and states
@item @tab @code{4} @tab yet to be defined ;)
@item @tab @code{5} @tab show detailed information on everything
@end multitable
@sp 1

The debug compilation of Fiona is not optimized to reach a high-performance. If you would like your
Fiona compilation to work better with respect to time, then you should configure it as follows:

@cartouche
@smallexample
./configure --disable-assert
@end smallexample
@end cartouche

Running configure with the mentioned parameter results in the definition of a preprocessor
directive called @samp{NDEBUG} in file @file{src/fiona.h}. @end itemize



@c --------------------------------------------------------------------------

@node Some last Words
@chapter Some last Words

We hope, that you will have fun using Fiona and that our tool actually helps you to reach your
goals. If you should, however, discover unusual behavior of Fiona, please do not hesitate to send
us an email (@email{fiona@@service-technology.org}). Describe the problem you have encountered
briefly, state the exact call that led to the buggy behavior and please also add the output of the
command

@cartouche
@smallexample
fiona --bug
@end smallexample
@end cartouche

to your email. That call lets Fiona state some facts about your local compilation. If possible, it
would be very helpful if you could attach your input files as well.

Thanks for using Fiona.



@c --------------------------------------------------------------------------

@node References
@chapter References

@table @asis
@itemx [1]
Schmidt, K.: Controllability of Open Workflow Nets. In: EMISA 2005. LNI, Bonner K@"ollen Verlag (2005) 236--249

@itemx [2]
Weinberg, D.: Efficient controllability analysis of open nets. In: WS-FM 2008. LNCS, Springer-Verlag (2008) accepted.

@itemx [3]
Lohmann, N., Massuthe, P., Wolf, K.: Operating Guidelines for Finite-State Services. In: ICATPN 2007. Volume 4546 of LNCS., Springer-Verlag (2007) 321--341

@itemx [4]
Massuthe, P., Reisig, W., Schmidt, K.: An Operating Guideline Approach to the SOA. AMCT 1(3) (2005) 35--43

@itemx [5]
Stahl, C., Massuthe, P., Bretschneider, J.: Deciding Substitutability of Services with Operating Guidelines. Technical Report 222, Humboldt-Universit@"at zu Berlin, Germany (2008) accepted for a journal.

@itemx [6]
Gierds, C., Mooij, A.J., Wolf, K.: Specifying and generating behavioral service adapter based on transformation rules. Technical Report CS-02-08, Universit@"at Rostock, Germany (2008) submitted to a conference.

@itemx [7]
Schmidt, K.: LoLA: A Low Level Analyser. In: ICATPN 2000. Volume 1825 of LNCS., Springer-Verlag (2000) 465--474

@itemx [8]
Lohmann, N.: A feature-complete Petri net semantics for WS-BPEL 2.0. In: WS-FM 2007. Volume 4937 of LNCS., Brisbane, Australia, Springer-Verlag (2008) 77--91

@itemx [9]
Stahl, C., Wolf, K.: Covering Places and Transitions in Open Nets. In: BPM 2008. Volume 5240 of LNCS., Milan, Italy, Springer-Verlag (2008) 116--131
@end table




@c --------------------------------------------------------------------------

@node First Steps
@chapter First Steps

@menu
* How to Get Fiona::
* How to Build Fiona::
* Software Dependencies::
* Testing Your Compilation::
* Further Make Targets::
* Contents of the Distribution::
@end menu


@node How to Get Fiona
@section How to Get Fiona


You can download the latest stable release of Fiona at

@url{http://service-technology.org/files/fiona}.

A nightly build of the most current (possibly unstable) version of Fiona is available at

@url{http://www.informatik.uni-rostock.de/~nl/cc}.

The Fiona project is hosted by @url{Gna.org}. Fiona's Subversion (SVN) repository can be
checked out through anonymous access over the SVN protocol (TCP 3690), or over http. Depending on
your network configuration you may prefer to use one or the other.

For checking out using the SVN protocol (TCP 3690), type

@cartouche
@smallexample
svn co svn://svn.gna.org/svn/service-tech/trunk/fiona
@end smallexample
@end cartouche

or, if you prefer to use http, type

@cartouche
@smallexample
svn co http://svn.gna.org/svn/service-tech/trunk/fiona
@end smallexample
@end cartouche
@sp 2


The distribution of Fiona was created using the GNU autotools. Detailed information on how to
build and install Fiona can be found in the file @file{INSTALL} in the root directory of
Fiona. If you are familiar with the setup and installation procedure of any GNU tool or you
already have a binary of Fiona you may skip the rest of this section.


@node How to Build Fiona
@section How to Build Fiona

@menu
* Preparing the SVN Respository::
* Preparing the tar-ball Distribution::
* Building Fiona::
@end menu

The steps of how to build Fiona depend on whether you downloaded a tar-ball containing the
current version of Fiona or whether you checked out the SVN repository.

@node Preparing the SVN Respository
@subsection Preparing the SVN Respository

Fiona was created using the GNU autotools. So, in order to install Fiona you need to do the
following steps. Successively type

@cartouche
@smallexample
aclocal
autoconf
autoheader
automake -a -c
@end smallexample
@end cartouche

Alternatively, you can also type

@cartouche
@smallexample
autoreconf -i
@end smallexample
@end cartouche

which will do the steps mentioned above for you.


@node Preparing the tar-ball Distribution
@subsection Preparing the tar-ball Distribution

After successful download of Fiona, version @value{VERSION}, change into your download directory and
type


@cartouche
@smallexample
tar xfz fiona-\release.tar.gz
cd fiona-\release
@end smallexample
@end cartouche


@node Building Fiona
@subsection Building Fiona

Once you have finished with the steps described above, you will find a file called
@file{configure} in your Fiona directory. Run the configure shell script by entering

@cartouche
@smallexample
./configure
@end smallexample
@end cartouche


which attempts to guess correct values for various system dependent variables used during
compilation and creates a @file{Makefile} in each directory of the package. Then, to build
the sources, enter

@cartouche
@smallexample
make
@end smallexample
@end cartouche

After compilation, a binary @file{src/fiona}@footnote{Under Windows the binary is called
@file{fiona.exe}} is generated. If you experience any compiler warnings, don't worry:
Fiona contains some generated or third party code that is not under our control. To install the
binary, type

@cartouche
@smallexample
make install
@end smallexample
@end cartouche

You might need superuser permissions to do so.

If you wish to fully delete Fiona from your system, type

@cartouche
@smallexample
make uninstall
@end smallexample
@end cartouche

Afterwards you just have to delete the directory of your Fiona distribution/ installation. Then
there should be no trace leading to Fiona on your system anymore.

The setup and installation procedure can be customized by running @file{./configure} with several
command-line options. Type

@cartouche
@smallexample
./configure --help
@end smallexample
@end cartouche


for more information.


@node Software Dependencies
@section Software Dependencies


In order to compile Fiona correctly and to use the whole functionality of Fiona please make
sure that the following software is installed on your machine.

@itemize
@item CygWin (@url{http://cygwin.com/}) (for Windows users only)
@item in case you checked out our SVN repository, you will need
  @itemize
    @item autoconf (@url{http://www.gnu.org/software/autoconf/}) and
    @item automake (@url{http://www.gnu.org/software/automake/})
    @item Flex (@url{http://flex.sourceforge.net/})
    @item Bison (@url{http://www.gnu.org/software/bison/})
  @end itemize
@item GCC (@url{http://gcc.gnu.org/})
@item Graphviz dot (@url{http://www.graphviz.org/}) to automatically create PNG files
@item petrify (@url{http://www.lsi.upc.edu/~jordicf/petrify/})\minus only needed for partner synthesis
@item CUDD (@url{http://vlsi.colorado.edu/~fabio/CUDD/}) for creating
        Binary Decision Diagrams (BDD) (the CUDD package is already part of the Fiona distribution)
@end itemize


@node Testing Your Compilation
@section Testing Your Compilation


The distribution of Fiona provides an extensive testsuite. In the directory called
@file{tests} you can find script files (@file{*.sh}) which define a set of tests that
correspond to certain functionalities of Fiona. The input files of each such test script are
located in a directory within the @file{tests} directory that has the same name as the script.

In order to test whether your Fiona compilation works well on your system there are special make
targets. The command

@cartouche
@smallexample
> make check
@end smallexample
@end cartouche


initiates Fiona to perform a number of self-tests: the test scripts (@file{<test>.sh}) are
successively invoked. Type

@cartouche
@smallexample
> make check-<test>
@end smallexample
@end cartouche


to invoke a single test script @file{<test>.sh} in the @file{tests} directory. For instance,
@file{make check-samples} calls the script @file{samples.sh}.


@node Further Make Targets
@section Further Make Targets


The generated Makefiles of Fiona provide different make targets. To build a Fiona Windows
executable which is independent of CygWin, type

@cartouche
@smallexample
make win32
@end smallexample
@end cartouche

To build a 64 bit executable of Fiona, type

@cartouche
@smallexample
make 64bit
@end smallexample
@end cartouche


In case you use the Fiona distribution from our SVN repository and you update the files rather
frequently, then it is advisable to clean up your current compilation before compiling it again.
Fiona provides a special make target that removes all generated files from your system. Type

@cartouche
@smallexample
make clean
@end smallexample
@end cartouche


@node Contents of the Distribution
@section Contents of the Distribution

The distribution contains several directories:

@table @file
@item doc
The Texinfo documentation of Fiona. The documentation can be created using @samp{make pdf}.

@item man
The manpage of Fiona which can be displayed using @samp{man fiona} after having Fiona installed (see Installation description above).

@item src
The source code of Fiona.

@item tests
Testcases for Fiona which check the generated binary.

@item nets
Some example open nets in the open net file format.

@end table


@c --------------------------------------------------------------------------


@node ChangeLog
@chapter Version History

Fiona is developed under the ``Release Early, Release Often'' maxime (see @url{http://catb.org/~esr/writings/cathedral-bazaar/cathedral-bazaar/ar01s04.html}): Whenever enough integrated or a non-trivial changes have summed up, a new version is published. Though this releases might now always mark significant changes, they at least allow to quickly fix bugs and avoid infinite procrastination.

@include ChangeLog.texi

@sp 3

The most recent change log is available at Fiona's website at @url{http://service-technology.org/files/fiona/ChangeLog}.



@c --------------------------------------------------------------------------

@node GNU Free Documentation License
@appendix The GNU Free Documentation License
@include fdl.texi

@bye
